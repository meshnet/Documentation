───────────────────────────────────────────────────────────────────────────────



                             NODE TO NODE PROTOCOL


                                MESHNET PROJECT

                             PROTOCOL SPECIFICATION

                                THIS IS A DRAFT

                                 November 2017






















                              louis@ne02ptzero.me


───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                               TABLE OF CONTENTS

1.  INTRODUCTION ............................................................ 3

  1.1 Scope of this document ................................................ 3
  1.2 Abbreviations ......................................................... 3
  1.3 References ............................................................ 3

2.  GENERAL DESCRIPTION ..................................................... 4

  2.1 Protocol Description .................................................. 4
  2.2 Frame ................................................................. 5
  2.3 Device Identification  ................................................ 5
  2.4 Packet Type ........................................................... 6
  2.5 Payload ............................................................... 6
  2.6 Version & Length ...................................................... 6

3.  PACKET TYPES ............................................................ 7

  3.1 PING .................................................................. 7
  3.2 PONG .................................................................. 7
  3.3 SERVICE ............................................................... 7
  3.4 PEERS ................................................................. 9

4. SERVICES .................................................................12

  4.1 CHAT ................................................................. 12
    4.1.1 Source and Destination User ID ................................... 12
    4.1.2 Sequence Number .................................................. 13
    4.1.3 Flags ............................................................ 13
    4.1.4 Message .......................................................... 14
  4.2 BROADCAST ............................................................ 15
    4.2.1 Issued Timestamp & Expires ....................................... 15
    4.2.2 Message .......................................................... 16

                                                                       [Page 1]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

5.  ROUTING ................................................................ 17

  5.1. PEER INFORMATIONS ................................................... 17
    5.1.1. Score calculation ............................................... 17
    5.1.2. Update Broadcast ................................................ 18
    5.1.3. Update Broadcast data optimization .............................. 18
  5.2. ROUTING ALGORITHM ................................................... 19
    5.2.1. General Description ............................................. 19
    5.2.2. Dijkstra's algorithm ............................................ 20
    5.2.3. Broadcast routing ............................................... 20

























                                                                       [Page 2]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                                1.  INTRODUCTION

The Node to Node protocol (N2NP) is intended for use as a reliable host-to-host
protocol between node devices (hosts) in packet-switched embedded computer
communication networks over radio waves.

This document describes the function to be performed by the Node to Node
Protocol, the programs that implements it, and its interface through a kernel
device driver.


1.1.  Scope of this document

  N2NP is a transport and applicative layer for the MeshNet project. It
  provides communication between two nodes, through radio signals. The physical
  layer (radio) is not yet defined as of this day, and it's not in the scope of
  this document. This document shall describe the internal mechanisms of the
  protocol, and its integration within the MeshNet project.

1.2.  Abbreviations

  ┏━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  ┃ Abbreviation ┃ Meaning                                                    ┃
  ┡━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩
  │ N2NP         │ Node-to-Node protocol                                      │
  ├──────────────┼────────────────────────────────────────────────────────────┤
  │ HW           │ Hardware                                                   │
  └──────────────┴────────────────────────────────────────────────────────────┘

1.3.  References

  [1] TCP RFC793           https://tools.ietf.org/html/rfc793
  [2] Dijkstra's_algorithm https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm


                                                                       [Page 3]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                            2.  GENERAL DESCRIPTION 

2.1.  Protocol Description


                               Protocol Layering

                              +------------------+
                              |                  |
                              |  Physical Layer  |
                              |                  |
                              +------------------+
                              |                  |
                              |       N2NP       |
                              |                  |
                              +------------------+

                                    Figure 1

  The N2NP protocol is over the physical layer [Figure 1]
  The physical layer is charged with transportation of the packet, and will be
  likely over radio waves, with low frequencies. That implies very low
  bandwidth, and the protocol must be designed with this requirement in mind.
  Since it does not handle transportation, the N2NP protocol can focus on the
  Routing and the data side of a communication.










                                                                       [Page 4]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

2.2.  Frame

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │ Major Version │ Minor Version │           Packet Length             │
├───────┼───────────────┴───────────────┼─────────────────────────────────────┤
│ 2     │         Packet Length         │            Packet Type              │
├───────┼───────────────────────────────┴─────────────────────────────────────┤
│ 4     │                                                                     │
├───────┤                   Source Device Identifier                          │
│ 6     │                                                                     │
├───────┼─────────────────────────────────────────────────────────────────────┤
│ 8     │                                                                     │
├───────┤                 Destination Device Identifier                       │
│ 10    │                                                                     │
├───────┼─────────────────────────────────────────────────────────────────────┤
│ 12    │                            Data ...                                 │
└───────┴─────────────────────────────────────────────────────────────────────┘


2.3  Device Identification

  In order to identify a device from another, the N2NP protocol use an hashed
  identifier, on 4 bytes. The original hashed content and the size of those
  fields are not decided yet, so those are subjects to changes.
  In a packet, the protocol shall define a source identifier (FROM) and a
  destination identifier (TO). These fields are to be used by the neighbors
  nodes in order to relay the packet to its final destination.
  A routing algorithm could be used too, in order to accelerate this process.



                                                                       [Page 5]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

2.4.  Packet Type

  In order to perform multiple actions, a packet type, on 1 byte, is set in
  the packet. This type contain a common integer that describes the type of
  action to be performed. Read the Type * sections for more information about
  them.

2.5.  Payload

  The payload of a packet (Data, in the Frame in 2.2) is filled with data.
  This field does not have a fixed size, and its content depends on the packet
  type. For example, a PING will not have any data.

2.6.  Version & Length

  The first byte of the packet is used to describe the protocol version. The
  first 4 bits are used for the major version, the last 4 bits for the minor
  version.

                              Example version byte

                          0100 .... = Major Version 4
                          .... 0101 = Minor Version 5


  The length field describe the total length of the packet, starting from byte
  0 of the N2NP header to last byte of the data field.








                                                                       [Page 6]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                                3.  PACKET TYPES

3.1. PING

  The PING packet type describes an action to test the reachability and the
  availability of a device. This type does not have any data paired with.
  On a PING, a device shall respond with a PONG in order to assure the original
  sender of its reachability.
  It is described with the value 0x1 (1) in the packet type field.

                           Typical ping-pong exchange

                          CLIENT_1 -> PING -> CLIENT_2
                          CLIENT_1 <- PONG <- CLIENT_2

3.2. PONG

  The PONG packet type describes a response to a previous PING packet. It is
  used to assure the availability of the receiver to the original sender.
  PONG is an obligatory response to a PING packet. If a client does not respond
  to a PING with a PONG, the original sender will assume that the receiver is
  not reachable. This type does not have any data paired with.
  It is described with the value 0x2 (2) in the packet type field.

3.3. SERVICE

  The SERVICE packet is used to describe a payload type, in order to the
  receiver to know what type of data will follow the header. If a SERVICE type
  is specified, data payload MUST follow the header. A data payload shall be
  always in the following frame:





                                                                       [Page 7]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                            Example Service Payload

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │        Service Type           │             Data Length             │
├───────┼───────────────────────────────┴─────────────────────────────────────┤
│ 2     │                            Data ...                                 │
└───────┴─────────────────────────────────────────────────────────────────────┘

  The Service Type field describes a 1 byte code used to define the service
  that it is used on this payload. Data Length describes the size of the
  following data field. One can chain multiple SERVICE payload:

                             Two services payloads

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │      First Service Type       │         First Data Length           │
├───────┼───────────────────────────────┴─────────────────────────────────────┤
│ 2     │                                                                     │
├───────┤                          First Data                                 │
│ X     │                                                                     │
├───────┼───────────────────────────────┬─────────────────────────────────────┤
│ X     │     Second Service Type       │         Second Data Length          │
├───────┼───────────────────────────────┴─────────────────────────────────────┤
│ X     │                                                                     │
├───────┤                         Second Data                                 │
│ X     │                                                                     │
└───────┴─────────────────────────────────────────────────────────────────────┘
                                                                       [Page 8]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

  See the SERVICES general section for more information about the content of
  data.

  The SERVICE packet type is described with 0x3 (3) in the packet type field.


3.4. PEERS

 The PEERS packet type describe the state of a node with its neighbors. It can
 be used for different purposes, when a client is joining the network, to 
 update the score of a peer or when a node loose a peer. It is described with
 the value 0x4 (4) in the packet type field.

                              PEERS packet header

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │           Peer size           │                Data                 │
├───────┼───────────────────────────────┘                                     │
│ 2     │                            Data ...                                 │
└───────┴─────────────────────────────────────────────────────────────────────┘


  The Peer size field does describe the number of couples score-ID
  present in the packet. A score - device ID pair is a simple data structure:







                                                                       [Page 9]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━╇━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │             Score             │             Device ID               │
├───────┼───────────────────────────────┘                                     │
│ 2     │                            Device ID                                │
├───────┤                               ┌─────────────────────────────────────┘
│ 4     │             Device ID         │
└───────┴───────────────────────────────┘

  The Score field describe the current score of the Device ID node, perceived
  by the source node; It is used to choose a best path when routing is needed.
  The Device ID describes the peer device ID, on 4 bytes.

  Those packets are broadcast by nature; If a client should receive a PEERS
  packet, the Destination Device Identifier in the N2NP header shall be set at
  0. Upon joining, a new node wanting to announce itself on the network must
  use a PEER packet: It announces the current peers of the node, and the score.
  For peer list and score calculation, see the relevant section. It is also
  used when a node want to announce an update on his peers: A peer has been 
  lost, a peer score has changed, or a new peer has arrived.

  Upon reception of a PEER packet, a client must update his intern routing 
  table with the informations in the PEER packet. A routing table entry consist
  of two things: The mother device ID, and a list of paired score-IDS of the
  peers linked with the mother device. It could be represented like that:







                                                                      [Page 10]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

    struct {
        uint32_t        node_id;

        struct {
            uint8_t             score;
            uint32_t            id;
            struct list_head    next;
        } neighbors;
    };

  The PEER packet is join-agnostic: A client receiving a packet must not care
  if the sender just joined the network or just updating informations about his
  peers. The client must update his intern routing table either way, and create
  a new entry when it is required. A C representation of the routing table
  could be:

    typedef struct {
        struct node_entry_s {
            uint32_t    node_id;

            struct {
                uint8_t                 score;
                struct node_entry_s     *id;
                struct list_head        next;
            };

            struct list_head            next;
        };
    } routing_table_t;

  It is worth noting that a pointer or a 32 bits unsigned int for the ID field
  will be the same thing, as both types takes 4 bytes in ARMv5l. Theoretically,
  an entry will size 25 bytes in memory; In practice, GCC will align the struct
  on an 8 byte word, therefore padding the structure up to 32 bytes.

                                                                      [Page 11]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                                  4.  SERVICES

4.1.  CHAT

  The CHAT service is used to describe a chat message between two or more
  users. It is described by the value 0x1 (1) in the service type field.

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │                         Source User ID                              │
├───────┼─────────────────────────────────────────────────────────────────────┤
│ 2     │                      Destination User ID                            │
├───────┼─────────────────────────────────────────────────────────────────────┤
│ 4     │                                                                     │
├───────┤                       Sequence Number                               │
│ 6     │                                                                     │
├───────┼──────────────────────────────┬──────────────────────────────────────┤
│ 8     │            Flags             │          Message Length              │
├───────┼──────────────────────────────┴──────────────────────────────────────┤
│ 10    │                           Message                                   │
└───────┴─────────────────────────────────────────────────────────────────────┘

4.1.1.  Source and Destination User ID

  The first two fields of a CHAT packet are the Source and Destination User ID.
  These are a hash on 16 bits, describing an User identifier. The source User
  ID must be the one of the packet sender. It is worth noting that if the flag
  CHAN is used in flags field, the Destination ID does not describe a user
  anymore, but a channel. See 4.1.3 section for more information about flags.
  One might think that this information is redundant with the devices IDs in
  the header, but the service should be able to support multiple users on a
  single device.
                                                                      [Page 12]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

4.1.2.  Sequence Number

  The Sequence Number field is used to describe a sequence in the
  communication. This information is useful to the devices, in order to track
  a progression in a communication. On the beginning of a session, the first
  packet sender shall set this field to 0. The mechanic behind it is the same
  as TCP[0], the receiver shall increment this field with length it received.

                          Example of a communication

      CLIENT_1 ->     CHAT "Hello", sequence_number = 0        -> CLIENT_2
      CLIENT_1 <- CHAT "Hey there !", ACK, sequence_number = 5 <- CLIENT_2
      CLIENT_1 ->      CHAT, ACK, sequence_number = 17         -> CLIENT_2

  The ACK flag is described in the 4.1.3 section.
  If a sequence number the maximum value of a 2 byte integer, the client that
  will overflow the sequence number shall re-beginning at 1.

4.1.3.  Flags

  The Flags field is used to describe multiple boolean information

                               1... .... = ACK
                               .1.. .... = CHA
                               ..1. .... = FRG
                               ...1 .... = Unused
                               .... 1... = Unused
                               .... .1.. = Unused
                               .... ..1. = Unused
                               .... ...1 = Unused

  The ACK flag describes an acknowledgment of data. If the ACK flag is set,
  the sequence number field shall contain the sequence of the data
  acknowledged.


                                                                      [Page 13]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

  The CHA flag describes a special case for the Destination User ID. If the
  flag is set, the Destination UserID field is not an UserID anymore, but
  rather a ChannelID, based on the same principle that a UserID.

  The FRG flag describes a fragmentation of data. If this flag is set, the
  receiver shall expect one or more packets in order to complete the data.

                              Fragmented exchange:

               CLIENT_1 -> CHAT "Hello", FRG, seq = 0 -> CLIENT_2
               CLIENT_1 <-     CHAT, ACK, seq = 5     <- CLIENT_2
               CLIENT_1 ->   CHAT "World !", seq = 0  -> CLIENT_2
               CLIENT_1 <-     CHAT, ACK, seq = 12    <- CLIENT_2

    In the example above, one can see that the CLIENT_2 ACKed the data before
    the reception of the second and final packet: It is not standard; The
    CLIENT_1 shall not wait for an acknowledgment of data before sending more
    fragmented packets. The exchange above could happen as:

                          Another Fragmented exchange:

               CLIENT_1 -> CHAT "Hello", FRG, seq = 0 -> CLIENT_2
               CLIENT_1 ->   CHAT "World !", seq = 0  -> CLIENT_2
               CLIENT_1 <-     CHAT, ACK, seq = 12    <- CLIENT_2

  When a client has sent the final packet of his fragmented data, the FRG flag
  must be unset; otherwise the other client will wait indefinitely for another
  packet.

4.1.4.  Message

  The Message field contain the payload message sent by the user to another
  one. It is assumed that this field is encoded with utf-8. The size of this
  field is described in the Message Length field. If this field is set at 0, it
  is assumed that the Message field will be empty.
                                                                      [Page 14]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

4.2.  BROADCAST

  The BROADCAST packet is used to describe a global message that needs to be
  sent to all the members of the network. It is described by the value 0x2 (2)
  in the service type field.
  It is worth noting that with this packet, the concept of destination is
  voided, since everyone on the network shall receive this packet. In this
  case, the Destination Device ID field in the N2NP header frame shall be set
  to 0 (zero).

┏━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Octet ┃               0               ┃                 1                   ┃
┃       ┣━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━┳━━━╋━━━┳━━━━━━━━┳━━━━┳━━━━┳━━━━┳━━━━┳━━━━┃
┃       ┃ 0 ┃ 1 ┃ 2 ┃ 3 ┃ 4 ┃ 5 ┃ 6 ┃ 7 ┃ 8 ┃ 9 ┃ 10 ┃ 11 ┃ 12 ┃ 13 ┃ 14 ┃ 15 ┃
┡━━━━━━━╇━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┻━━━━┩
│ 0     │                                                                     │
├───────┤                        Issued Timestamp                             │
│ 2     │                                                                     │
├───────┼──────────────────────────────┬──────────────────────────────────────┤
│ 4     │           Expires            │          Message Length              │
├───────┼──────────────────────────────┴──────────────────────────────────────┤
│ 6     │                           Message                                   │
└───────┴─────────────────────────────────────────────────────────────────────┘

4.2.1.  Issued Timestamp & Expires

  The first four bytes describes a Unix EPOCH timestamp. This timestamp is the
  time at which the broadcast shall be delivered (client-side, not protocol
  side). It can be in the future, the firmware should handle the proper
  delivery of the broadcast to the differents applications.
  The Expires field describes the number of hours that the broadcast is valid
  starting from the Issued timestamp. Client should be doing the following
  addition in order to check the validity of a broadcast

                                                                      [Page 15]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                  Condition to check the validity of broadcast

                time(NULL) < issued_timestamp + (expires * 3600)

4.2.2.  Message

  The Message field contain the data to be delivered; It is not formatted in
  any fashion. In order to get the size of this data, one must use the
  Message Length field.



























                                                                      [Page 16]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                                  5.  ROUTING

Withing the N2NP protocol, routing is done in a special way. Since the network
mesh is router-less, the routing protocol needs to be gateway agnostic. We 
also have low-data requirements due to physical transportation limitation. And the
node on the network will be moving, so we need high reliability.

The entire routing is based on the principle that all nodes on the network 
knows every node's neighbors; Therefore, every node can determine a path for
every packet.

5.1.  PEER INFORMATIONS

Peers neighbors are not the only information provided by every host on the
network; Every host assign a score to their neighbors, based on signal strength
and distance. This value is to be used in the heuristic algorithm in order
to evaluate the weight of a path.

5.1.1.  Score calculation

  A score describes the state of a node from the point of of view of another
  node. Those two nodes must be withing physical reach for a score to be 
  determined: it is used as weight value for the path-finding heuristic.
  A score is determined through the following equation / heuristic:

           /!\ To be determined, needs to be on one byte maximum /!\









                                                                    [Page 17]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

5.1.2.  Update Broadcast

  This broadcast is launched when one of the following conditions are met:
  - A new node is joining the network
  - An existing node got a new neighbor (New client or a moving node)
  - A node has timed out
  - A peer score has changed

  In all of thoses cases, the main node needs to update the whole network if
  this new information; In order to calculate a path reliably, every node on
  the network must know the neighbors of everyone: It is not intended to be
  a real-time information, but rather an indicative information.
  In order to do that, the node must sent a PEERS packet with all the neighbors
  information. If a peer did timeout, the main node must sent a PEER entry
  with a score of 0 (zero). If a peer did not change score, the main node must
  not add it in its PEERS packet.

5.1.3. Update broadcast data optimization

  In order to optimize usage of data bandwidth, broadcast peer update data must be packed
  whenever its possible. If a node B is to retransmit the update data of the
  node A, and the node B itself has broadcast data in the output pipe, the 
  B node must pack the node A information with his information, and send one
  and only packet to be relayed by its peers. Of course, this packed data
  length should not exceed the packet maximum size, otherwise the first packet
  must be relayed without re-writing, and the second one sent aswell.
  A client, receiving broadcast update data from multiple clients in one packet
  must deduce the number of nodes implicated by looking at the total length
  in the N2NP header.






                                                                     [Page 18]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

5.2. ROUTING ALGORITHM

When a packet is sent from one device with the intent of speaking to a another
device directly, routing must be involved. In order to assure delivering 
reliability, the N2NP uses a mix between an HEAT algorithm, with node score
attribution, and a static route routing algorithm. You can find the details
about score attribution in the relevant section, along with the routing table
information.

5.2.1.  General Description

  The concept of this routing algorithm is quite simple: Every node bound to
  route a packet from a node A to a node B must determine which route is the 
  best, on every hop. Let's say we have a node A wanting to send a packet to 
  node Z; The simple scenario is that those two nodes are physically next to
  each other: Therefore, no routing is needed. But, if those two nodes are not
  connected between each other, node A must determine the best route to reach
  node Z. In order to do that, and with all the information about all the
  nodes on the network (See PEERS), the node A must run an heuristic algorithm
  on all his peers node (physically connected) with the score of each node as
  weight. In order not to loose time in the process, the depth used for the
  algorithm should be minimal: The node A do not need to determine an exact 
  perfect path all the way to node Z, but rather choose between his direct
  peers, the one that will be more suited to route this packet.

                              Example mesh network

                / -- Node C - \                       /----- Node E ------
       / Node B                Node D ------->  Node F                    \
Node A         \ Node G ----- /    |                  \-- Node H         Node Z
                                    \ Node I                  \  Node J /




                                                                     [Page 19]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

  Let's take the above schema: In this example, the node A still wants to reach
  the node Z. In order to do that, the node A must determine the best path from
  his direct peer; In this case it's quite simple the node A only has one peer.
  Node A sents the packet to Node B, and it's the turn of Node B to determine
  the best path from his peer. Here, we got two peers nodes: C and G. With the
  both score of those direct peers, and all the ones beyond those ones, node B
  must know determine the best path to route this packet. It is important to 
  note that the node B intern routing table, that describes all the scores of
  everyone on the network, don't need to be updated in real time: The node can
  determine a good-enough-path to next peer with his data. Let's say, for the 
  sake of the example, that node C has a score of 40, and G, a score of 55.
  Since both C and G share the same exit node, D, their exit score will be the
  same. So the node B must compare the score of C and G in order to route the
  packet properly. In this example, G got a bigger score than C, so the node B 
  will route the packet to G. The node G on reception, will do the same 
  algorithm in order to route the packet to the next node, and the next node
  will do the same, and so on to the final destination node.

5.2.2. Dijkstra's algorithm

  In order to compute the best path for a packet, a node must use the 
  Dijkstra's algorithm[1]. Instead of using distance as a sole weight
  parameter, the score of the nodes is to be used. See the relevant sections
  for score calculations.

5.2.3. Broadcast routing

  By nature, broadcast packets do not have a destination: All the members of the
  networks shall receive the packet. Therefore, the routing algorithm cannot be
  used in this case. A flood routing algorithm is to be used.





                                                                     [Page 20]
───────────────────────────────────────────────────────────────────────────────
───────────────────────────────────────────────────────────────────────────────
November 2017                                             Node to Node Protocol

                             Simple 4 nodes network

                                     Node A
                                    /     \
                               Node B     Node D
                                    \     /
                                     Node C

  Lets take the above schema: In this example, the node A wants to broadcast
  a packet to the network: First, it will send it to his direct neighbors:
  B and D. Before sending, the node must compute a checksum of the full packet,
  starting at the N2NP header, and store it. The node D, upon reception of the 
  packet, and before userland treatment, must do the same: Compute a checksum,
  and send the packet to his direct neighbors, A and C. C has never seen the
  packet before: Therefore it will compute and relay it. But the node A has
  already seen the packet (Since he's the one who sent it). So, upon reception,
  A will compute the checksum, check with his internal storage, see that
  this packet has already been relayed, and simply drop it.
  With this method, we keep simplicity through routing, without much data
  overhead and broadcast replay problems.















                                                                     [Page 21]
───────────────────────────────────────────────────────────────────────────────
